#+INCLUDE: ../orgopts.org
#+TITLE: მეშვიდე სემინარი
* ამ სემინარის მიზნები: :note:
- ლექციაზე განხილული საკითხების/ფუნქციების დეტალები
- ფუნქციის მიმმართვალების (კონკრეტულად მათი ტაიპების)
* generic linear search
** ფუნქციის კოდი
გამეორება
- ამ ფუნქციის თავიდან დაწერა (ჯერ კოდის გარეშე პროცესის აღწერა, მერე კოდის)
- cmp ფუნქციის დაწერა
#+INCLUDE: ../snippets/lsearch.c src c

** არგუმენტად მიწოდებული შედარების ფუნქცია
ლექციის ჩანაწერი:
because I am writing this function, specifically to make this call, this constrains the prototype to take two void
*'s, but I know that they're really int *'s. So because I'm writing that code as a client, I canreinterpret the void *'s to be the int *'s that they really are. So I will do this, int * ip 2, and
I will just set it equal to lm 1 and lm 2. It turns out in a pure C compile you do not need to
do a cast there, it just understands that the cast is implicit

მნიშვნელოვანი სიტყვები
- ფუნქციის პროტოტიპი (ეწოდება ფუნქციის აღწერას {} -ის გარეშე, header file შიც
  პროტოტიპები გვიწერია). ასევე ეძახიან signature. რა ეწოდება მთლიან ფუნქციას -> დეფინიცია
- პროტოტიპის შეზღუდვა (constraint)
- კლიენტი

შენიშვნა: ეს ფუნქციები არის სხვადასხვა ფაილში, და cmp სადაც ვწერთ იქ გვაქვს პროტოტიპი
** related
*** სხვადასხვა სახელები, რომელსაც საფუძვლად ერთი იდეა უდევს
- header file/source file
  - ჰედერი სადაცაა ის შეგიძლია დააკომპაილო და მერე ალტერნატიული source file
    მიაწოდო საბოლოო დაკომპაილებისას
- ინტერფეისი და იმპლემენტაცია (ჯავა)
- front/back end
- კლიენტი და სერვერი
- აბსტრაქციის საფეხური
უნივერსალური ცნებაა
*** კავშირი generics-თან
- ინფორმაციის ორგანიზება და გადაწოდება
- რა არის ის მინიმალური ინფორმაცია, რითიც მაქსიმალურ ეფექტურობას მივაღწევთ?

ეს ცნებები არის ფუნდამენტური - ფაილიდან ფაილში და ფუნქციიდან ფუნქციაშიც კი.
ყოველთვის დაფიქრდით პასუხისმგებლობებზე (ფუნქციის მიზანია მოძებნა და არა შედარება)
*** generics-ის მიზნები
- კოდის დუპლიკაცია
- პროცესის *ზოგადი* აღწერა
- ძალისხმევის კონცენტრირება -> ყველა იდეა, რომელიც ალგორითმს გააუმჯობესებს,
  გაფანტული არ იქნება სხვადასხვა ვარიანტებში
*** კავშირი იუნუქსის ფილოსოფიასთან
- ერთი პასუხისმგებლობა, რომელსაც კარგად ასრულებ
- კომპოზიცია
* ფუნქციები
** მიმმართველები
- ხშირად მოიხსენიებენ, როგორც callback-ს
*** რა ხდება, როდესაც ფუნქციას ვიძახებთ
- მეხსიერებაში უკვე არის კოდი მისამართზე, და ამ კოდს აქქვს მისამართი
  არგუმენტების, რომელიც გამოძახებისას გადაკოპირდა სტეკზე
- როდესაც ფუნქციას ვაწვდით სხვა ფუნქციის მისამართს, ზუსტად იგივე პროცესი მიმდინარეობს

ამ პროცესს უფრო დეტალურად რამდენიმე კვირაში გავივლით
*** რა ახალი შესაძლებლობა გვაქვს ამით
ცვლადი - value
ფუნქცია - ქცევა, გადაწყვეტილების მიღების ხელსაწყო
*** რატომაა აუცილებელი მისამართის მიწოდება
 რა მოხდება, თუ უბრალოდ ვიგულისხმებთ რომ ეს ფუნქცია დაწერილია და გამოვიძახებთ?
  - #include ების სერია ჩაკოპირდება მთავარ ფაილში და ეს ფუნქცია "გამოჩნდება" ->
    იმ შემთხვევაში თუ ყველა ფაილს ერთად დააკომპაილებ, მართლა იმუშავებს
  - რა შემთხვევაში არ მოხდება ასე? -> "gcc -c" არგუმენტით დაკომპაილების
    შემთხვევაში (object file)
  - რომელს ვიყენებთ უფრო ხშირად? -> ცალკე დაკომპაილებას
  - შენიშვნა: ასე რომც არ იყოს, გულისხმობა ნიშნავს რომ დამატებითი ინფორმაცია იქნება დოკუმენტაციაში.
    დოკუმენტაცია აუცილებელია, მაგრამ მაქსიმალური ინფორმაცია უნდა მიაწოდო
** მიმმართველის type
ამ რესურსებიდან (უმეტესად პირველი) მნიშვნელოვანი სნიპეტების ამოკრებვა
*** მიმმართველები
**** ფუნქციის მიმმართველები
***** კარგი შეჯამება
https://www.cprogramming.com/tutorial/function-pointers.html
&, * ოპერატორები ისევე მუშაობს, როგორც მასივზე ან ნებისმიერ სხვა მიმმართველზე
***** გამოყენება
https://www.geeksforgeeks.org/function-pointer-in-c/
- შეგვიძლია შევინახოთ, როგორც სხვა ნებისმიერი ცვლადი
- 4-ში არის მაგალითი ფუნქციების მიმმართველების მასივის
***** typedef გამოყენება
https://stackoverflow.com/a/840504
***** optional: უფრო დეტალურად და რთული მაგალითებით
https://www.codingame.com/playgrounds/14589/how-to-play-with-pointers-in-c/function-pointers
https://www.learn-c.org/en/Function_Pointers
**** pointer types
https://stackoverflow.com/a/7707202
* selection sort
** საჭირო ფუნქციები
#+INCLUDE: ../classwork/selection_sort/selection_sort.h src c
** სემინარზე დაწერილი swap ფუნქცია
#+BEGIN_SRC c
void swap(void *vp1, void *vp2, int size)
{
    char buffer[size];
    memcpy(buffer, vp1, size);
    memcpy(vp1, vp2, size);
    memcpy(vp2, buffer, size);
}
#+END_SRC
** დავალება: იმპლემენტაციის დასრულება
შემოწმება შემდეგ სემინარში
