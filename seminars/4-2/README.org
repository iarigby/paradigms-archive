#+INCLUDE: ../orgopts.org
#+TITLE: მერვე სემინარი
* generic stack
** რა განსხვავებაა ფუნქციის პროტოტიპებს შორის?
- მინიმალური განსხვავება, რადგანაც ზომას კონსტრუქციისას ვაწვდით
- რატომ ვაწვდით გათავისუფლებას კონსტრუქციისას?
** stackpop: რატომ ვაწვდით elemAddr, იმის მაგივრად რომ void* დავაბრუნოთ?
ამ შემთხვევაში malloc() მოგვიწევდა, და მაშინ freeსაც ჩვენ უნდავაკეთებდეთ
** stack pushთან რა ფუნქციების გამოძახებაა აუცილებელი?
malloc (ან მისი შემცველი რომელიმე ფუნქცია, მაგალითად strdup), free()
** როდის ხდება free?
stackPopის მერე
** რატომ არ ვწერთ free(s) დესტრუქტორში?
იმიტომ, რომ malloc() ჩვენ არ დაგვიწერია
** ownership details
- stackpush -> ელემენტზე მფლობელობის გადაცემა სტეკისტვის
- stackpop -> მფლობელობის კლიენტისთვის დაბრუნება
* რჩევები მეხსიერების ფუნქციებთან მუშაობისთვის
- free() იძახებთ, თუ:
  1. malloc() გამოიძახეთ და მიმმართველის მფლობელობა სხვისთვის არ დაგიბრუნებიათ
  2. მიმმართველის მფლობელობა გადმოგცეს და მისი მფლობელობა სხვისთვის არ დაგიბრუნებიათ
- სტრქუტურის შექმნისას ან გამოყენებისას დაფიქრდით, რომელი ფუნქციებით ხდება მიმმართველის
  მფლობელობის შეცვლა და .h ფაილში ფუნქციის პროტოტიპამდე კომენტარში დაწერეთ. ამით
  გაგიმარტივდებათ მფლობელობასთან დაკავშირებულ საკითხებზე გადაწყვეტილების მიღება
* realloc
** რა ორი გზით შეიძლება მოიქცეს ეს ფუნქცია
- თუ გვერდით საკმარისი მეხსიერებაა თავისუფალი
- თუ არაა
  1. malloc() აკეთებს მოთხოვნილი ზომის მეხსიერების ალოკაციას სხვაგან
  2. memcpy()
  3. free()
  4. აბრუნებს ახალ მისამართს
- თუ პირველი არგუმენტი null არის, უბრალოდ mallocს აკეთებს
** რა შემთხვევაშია აუცილებელი დაბრუნებული მისამართის შენახვა
ყოველთვის უნდა შევინახოთ
** რა მოხდება, თუ დაგვავიწყდა
ძველი მიმმართველი გათავისუფლებულ მეხსიერებაზე მიუთითებს
** როგორ დავრწმუნდეთ ფუნქციის წარმატებით გამოძახებაში?
assert. თუ ვერ მოხდა რეალოკაცია, nullს აბრუნებს (და ძველი მეხსიერება რჩება)
შენიშვნა: თუ გვინდა failის შემთხვევაში გავაგრძელოთ პროგრამა,
ამ შემთხვევისთვის ლექციაზე მოცემული კოდი არაა საკმარისი, ახალი
ფოინთერი უნდა შეიქმნას, შემოწმდეს ნოლობაზე, თუ ცარიელია, არ შევცვალოთ ძველი.
ის კოდი იმიტომ მუშაობს რომ assert failure შეწყვეტს executionს
** const pointer თუ გვაქვს, როგორ გამოვიყენოთ?
ახალი ცვლადი (თუნდაც ისევ const)
- არის თუ არა ამ შემთხვევაში ძველის გათავისუფლება აუცილებელი? -> არა, უბრალოდ
  ერთი რიცხვია და ავტომატურად წაიშლება

* განსხვავება მეთოდსა და ფუქნციას შორის
- სტეკის ფუნქციებს, რომელიც დაწერეთ, რაღაც სტეკის მისამართი აქვთ. რა არის ამის
ეკვივალენტი c++ და java-ში? "this"

"When I’m talking about the type of number functions or functions that are inside classes,
I don’t refer to them as functions, I refer to them as methods. The difference between a
function and a method, they look very similar, except that methods actually have the
address of the relevant object lying around as this invisible parameter via this invisible
parameter called this."
* ssort
[[file:../classwork/selection_sort][სრული კოდი]]
** შენიშვნები
#+BEGIN_SRC c
if (cmpfn(ptr, minptr) < 0) == if(cmpfn(minptr, ptr) > 0)
#+END_SRC
ეკვივალენტურია ორივე გზა: თუ ახლანდელი მინიმუმზე მეტი ელემენტი ვიპოვეთ vs თუ ახლანდელ მინიმუმზე ნაკლები
ელემენტი ვიპოვეთ. პირველი გზა უფრო ახლოსაა ალგორითმის ფორმალურ სპეციფიკაციასთან
და სჯობს უფრო მარტივი და ცხადი რომელიცაა, ის გამოიყენოთ

#+BEGIN_SRC c
if (iMin != j)
    swap(minptr, (char *)base + j * elemSize, elemSize);
#+END_SRC
if თუ გამოგვრჩა, 3-ჯერ გამოვიძახებთ memcpy-ს საჭიროების გარეშე. დაფიქრდით იმ
შემთხვევაზე, როცა მიღებული მასივი თითქმის დალაგებულია და რეალურად სულ რამდენიმე
ელემენტია შესაცვლელი.
** doublecmp
- 1/3 * 3 უნდა იყოს 1 თუ 0.(9)? რა ვიცით 0.(3) საიდან მივიღეთ?
- მარტო c-სთან დაკავშირებული საკითხი არაა
- ასეთი უზუსტობების გამო ტოლობის ნიშანს არ ვიყენებთ -> მანძილი
* დამატებით: Floating point arithmetic
https://floating-point-gui.de
